// Generated by CoffeeScript 1.4.0
(function() {
  var TVDB, Zip, fs, http, querystring, xmlParser, _;

  xmlParser = new (require("xml2js")).Parser({
    explicitRoot: false,
    explicitArray: false
  });

  http = require("http");

  _ = require("underscore");

  querystring = require("querystring");

  fs = require("fs");

  Zip = require('node-zip');

  TVDB = (function() {
    var defaultOptions;

    defaultOptions = {
      apiKey: null,
      language: "en",
      initialHost: "thetvdb.com",
      port: 80
    };

    function TVDB(options) {
      this.options = _.extend(_.clone(defaultOptions), options || {});
      if (!this.options.apiKey) {
        throw new Error("You have to provide an API key.");
      }
    }

    TVDB.prototype.setLanguage = function(abbreviation) {
      return this.options.language = abbreviation;
    };

    TVDB.prototype.setMirror = function(host, port) {
      if (host != null) {
        this.options.initialHost = host;
      }
      if (port != null) {
        return this.options.port = port;
      }
    };

    TVDB.prototype.paths = {
      mirrors: '/api/#{apiKey}/mirrors.xml',
      languages: '/api/#{apiKey}/languages.xml',
      serverTime: '/api/Updates.php?type=none',
      findTvShow: '/api/GetSeries.php?seriesname=#{name}&language=#{language}',
      getInfo: '/api/#{apiKey}/series/#{seriesId}/all/#{language}.zip',
      getInfoTvShow: '/api/#{apiKey}/series/#{seriesId}/#{language}.xml',
      getInfoEpisode: '/api/#{apiKey}/episodes/#{episodesId}/#{language}.xml',
      getUpdates: '/api/#{apiKey}/updates/updates_#{period}.zip'
    };

    TVDB.prototype.getPath = function(pathName, values) {
      var path;
      path = this.paths[pathName];
      _.each(_.extend({}, this.options, values), function(value, key) {
        return path = path.replace('#{' + key + '}', querystring.escape(value));
      });
      return path;
    };

    TVDB.prototype.get = function(options, callback) {
      var _this = this;
      options = _.extend({
        host: this.options.initialHost,
        port: this.options.port
      }, options);
      if (options.pathName != null) {
        options.path = this.getPath(options.pathName);
        delete options.pathName;
      }
      return http.get(options, function(res) {
        var contentType, dataBuffers, dataLen, _ref;
        if (!((100 <= (_ref = res.statusCode) && _ref < 300))) {
          callback(new Error("Status: " + res.statusCode));
          return;
        }
        contentType = res.headers['content-type'];
        if (contentType.split(';').length) {
          contentType = contentType.split(';')[0];
        }
        dataBuffers = [];
        dataLen = 0;
        res.on('data', function(chunk) {
          dataBuffers.push(chunk);
          return dataLen += chunk.length;
        });
        return res.on('end', function() {
          var data, dataBuffer, i, pos, _i, _len;
          dataBuffer = new Buffer(dataLen);
          pos = 0;
          for (i = _i = 0, _len = dataBuffers.length; _i < _len; i = ++_i) {
            data = dataBuffers[i];
            data.copy(dataBuffer, pos);
            pos += data.length;
          }
          switch (contentType) {
            case "text/xml":
            case "application/xml":
              return xmlParser.parseString(dataBuffer.toString(), function(err, result) {
                if (err != null) {
                  err = new Error("Invalid XML: " + err.message);
                }
                return callback(err, result);
              });
            case "application/zip":
              return _this.unzip(dataBuffer, function(err, result) {
                if (err != null) {
                  err = new Error("Invalid XML: " + err.message);
                }
                return callback(err, result);
              });
            default:
              return callback(null, dataBuffer.toString());
          }
        });
      }).on("error", function(e) {
        return callback(e);
      });
    };

    TVDB.prototype.getLanguages = function(done) {
      return this.get({
        pathName: "languages"
      }, function(err, response) {
        var languages;
        if (err != null) {
          done(err);
          return;
        }
        languages = _.isArray(response.Language) ? response.Language : [response.Language];
        return done(void 0, languages);
      });
    };

    TVDB.prototype.getMirrors = function(done) {
      return this.get({
        pathName: "mirrors"
      }, function(err, response) {
        var formattedMirrors, masks, mirrors;
        if (err != null) {
          done(err);
          return;
        }
        mirrors = _.isArray(response.Mirror) ? response.Mirror : [response.Mirror];
        masks = {
          xml: 1,
          banner: 2,
          zip: 4
        };
        formattedMirrors = [];
        mirrors.forEach(function(mirror) {
          var formattedMirror;
          formattedMirror = {
            id: mirror.id,
            url: mirror.mirrorpath,
            types: []
          };
          _.each(masks, function(mask, type) {
            if ((mirror.typemask & mask) === mask) {
              return formattedMirror.types.push(type);
            }
          });
          return formattedMirrors.push(formattedMirror);
        });
        return done(void 0, formattedMirrors);
      });
    };

    TVDB.prototype.getServerTime = function(done) {
      return this.get({
        pathName: "serverTime"
      }, function(err, response) {
        if (err != null) {
          done(err);
          return;
        }
        return done(void 0, parseInt(response.Time, 10));
      });
    };

    TVDB.prototype.findTvShow = function(name, done) {
      return this.get({
        path: this.getPath("findTvShow", {
          name: name
        })
      }, function(err, tvShows) {
        var formattedTvShows, keyMapping;
        if (err != null) {
          return done(err);
        }
        formattedTvShows = [];
        if ((tvShows != null ? tvShows.Series : void 0) != null) {
          tvShows = _.isArray(tvShows.Series) ? tvShows.Series : [tvShows.Series];
          keyMapping = {
            IMDB_ID: 'imdbId',
            zap2it_id: 'zap2itId',
            banner: 'banner',
            Overview: 'overview'
          };
          tvShows.forEach(function(tvShow) {
            var formattedTvShow;
            formattedTvShow = {
              id: tvShow.id,
              language: tvShow.language,
              name: tvShow.SeriesName
            };
            if (tvShow.FirstAired != null) {
              formattedTvShow.firstAired = new Date(tvShow.FirstAired);
            }
            _.each(keyMapping, function(trgKey, srcKey) {
              var srcValue;
              srcValue = tvShow[srcKey];
              if (srcValue) {
                return formattedTvShow[trgKey] = srcValue;
              }
            });
            return formattedTvShows.push(formattedTvShow);
          });
        }
        return done(void 0, formattedTvShows);
      });
    };

    TVDB.prototype.getInfo = function(tvShowId, done, language) {
      var options, self;
      options = {
        language: 'en',
        seriesId: tvShowId
      };
      if (language != null) {
        options.language = language;
      }
      self = this;
      return this.get({
        path: this.getPath("getInfo", options)
      }, function(err, files) {
        var filename, formattedResult, xml;
        if (err != null) {
          return done(err);
        }
        formattedResult = {};
        for (filename in files) {
          xml = files[filename];
          xmlParser.parseString(xml, function(err, result) {
            var actors, banners, episodes, formattedActors, formattedBanners, formattedEpisodes, keyMapping;
            if (err != null) {
              return done(new Error("Invalid XML: " + err.message));
            }
            if (result.Actor != null) {
              formattedActors = [];
              keyMapping = {
                Image: 'image',
                Role: 'role',
                SortOrder: 'sortOrder'
              };
              actors = _.isArray(result.Actor) ? result.Actor : [result.Actor];
              actors.forEach(function(actor) {
                var formattedActor;
                formattedActor = {
                  id: actor.id,
                  name: actor.Name
                };
                _.each(keyMapping, function(trgKey, srcKey) {
                  var srcValue;
                  srcValue = actor[srcKey];
                  if (srcValue) {
                    return formattedActor[trgKey] = srcValue;
                  }
                });
                return formattedActors.push(formattedActor);
              });
              formattedResult['actors'] = formattedActors;
            }
            if (result.Banner != null) {
              formattedBanners = [];
              keyMapping = {
                Colors: 'colors',
                ThumbnailPath: 'thumbnailPath',
                VigettePath: 'vigenettePath',
                Season: 'season'
              };
              banners = _.isArray(result.Banner) ? result.Banner : [result.Banner];
              banners.forEach(function(banner) {
                var formattedBanner;
                formattedBanner = {
                  id: banner.id,
                  path: banner.BannerPath,
                  type: banner.BannerType,
                  type2: banner.BannerType2,
                  language: banner.Language,
                  rating: banner.Rating,
                  ratingCount: banner.RatingCount
                };
                _.each(keyMapping, function(trgKey, srcKey) {
                  var srcValue;
                  srcValue = banner[srcKey];
                  if (srcValue) {
                    return formattedBanner[trgKey] = srcValue;
                  }
                });
                return formattedBanners.push(formattedBanner);
              });
              formattedResult['banners'] = formattedBanners;
            }
            if (result.Series != null) {
              formattedResult['tvShow'] = self.formatTvShow(result.Series);
            }
            if (result.Episode != null) {
              formattedEpisodes = [];
              episodes = _.isArray(result.Episode) ? result.Episode : [result.Episode];
              episodes.forEach(function(episode) {
                return formattedEpisodes.push(self.formatEpisode(episode));
              });
              return formattedResult['episodes'] = formattedEpisodes;
            }
          });
        }
        return done(void 0, formattedResult);
      });
    };

    TVDB.prototype.getInfoTvShow = function(tvShowId, done, language) {
      var options, self;
      options = {
        language: 'en',
        seriesId: tvShowId
      };
      if (language != null) {
        options.language = language;
      }
      self = this;
      return this.get({
        path: this.getPath("getInfoTvShow", options)
      }, function(err, files) {
        if (err != null) {
          return done(err);
        }
        return done(void 0, self.formatTvShow(files.Series));
      });
    };

    TVDB.prototype.getInfoEpisode = function(episodeId, done, language) {
      var options, self;
      options = {
        language: 'en',
        episodesId: episodeId
      };
      if (language != null) {
        options.language = language;
      }
      self = this;
      return this.get({
        path: this.getPath("getInfoEpisode", options)
      }, function(err, files) {
        if (err != null) {
          return done(err);
        }
        return done(void 0, self.formatEpisode(files.Episode));
      });
    };

    TVDB.prototype.unzip = function(zipBuffer, done) {
      var files, zip;
      zip = new Zip(zipBuffer.toString("base64"), {
        base64: true,
        checkCRC32: true
      });
      files = {};
      _.each(zip.files, function(file, index) {
        return files[file.name] = file.data;
      });
      return done(null, files);
    };

    TVDB.prototype.getUpdates = function(period, done) {
      var options;
      if (!(['day', 'week', 'month'].some(function(p) {
        return p === period;
      }))) {
        return done(new Error("Invalid period " + period));
      }
      options = {
        period: period
      };
      return this.get({
        path: this.getPath("getUpdates", options)
      }, function(err, files) {
        var formattedResult;
        if (err != null) {
          return done(err);
        }
        formattedResult = {};
        _.each(files, function(xml) {
          return xmlParser.parseString(xml, function(err, updates) {
            if (err != null) {
              return done(new Error("Invalid XML: " + err.message));
            }
            return _.each(updates, function(update, key) {
              if (key === "$") {
                return formattedResult['updateInfo'] = update;
              } else if (key === "Series") {
                return formattedResult['tvShows'] = update;
              } else if (key === "Episode") {
                formattedResult['episodes'] = [];
                return _.each(update, function(episode) {
                  return formattedResult['episodes'].push({
                    id: episode.id,
                    tvShowId: episode.Series,
                    time: episode.time
                  });
                });
              } else if (key === "Banner") {
                formattedResult['banners'] = [];
                return _.each(update, function(banner) {
                  var bannerInfo;
                  bannerInfo = {
                    tvShowId: banner.Series,
                    path: banner.path,
                    time: banner.time,
                    type: banner.type
                  };
                  if (banner.SeasonNum != null) {
                    bannerInfo.season = banner.SeasonNum;
                  }
                  if (banner.format != null) {
                    bannerInfo.format = banner.format;
                  }
                  if (banner.language != null) {
                    bannerInfo.language = banner.language;
                  }
                  return formattedResult['banners'].push(bannerInfo);
                });
              }
            });
          });
        });
        return done(void 0, formattedResult);
      });
    };

    TVDB.prototype.formatTvShow = function(tvShow) {
      var formattedTvShow, keyMapping;
      keyMapping = {
        IMDB_ID: 'imdbId',
        zap2it_id: 'zap2itId',
        banner: 'banner',
        Overview: 'overview'
      };
      formattedTvShow = {
        id: tvShow.id,
        genre: tvShow.Genre,
        language: tvShow.Language,
        name: tvShow.SeriesName
      };
      if (tvShow.FirstAired != null) {
        formattedTvShow.firstAired = new Date(tvShow.FirstAired);
      }
      _.each(keyMapping, function(trgKey, srcKey) {
        var srcValue;
        srcValue = tvShow[srcKey];
        if (srcValue) {
          return formattedTvShow[trgKey] = srcValue;
        }
      });
      return formattedTvShow;
    };

    TVDB.prototype.formatEpisode = function(episode) {
      var formattedEpisode, keyMapping;
      keyMapping = {
        Overview: 'overview',
        Rating: 'rating',
        RatingCount: 'ratingCount',
        Writer: 'writer'
      };
      formattedEpisode = {
        id: episode.id,
        name: episode.EpisodeName,
        number: episode.EpisodeNumber,
        language: episode.Language,
        season: episode.SeasonNumber,
        seasonId: episode.seasonid,
        tvShowId: episode.seriesid,
        lastUpdated: episode.lastupdated
      };
      if (episode.FirstAired != null) {
        formattedEpisode.firstAired = new Date(episode.FirstAired);
      }
      _.each(keyMapping, function(trgKey, srcKey) {
        var srcValue;
        srcValue = episode[srcKey];
        if (srcValue) {
          return formattedEpisode[trgKey] = srcValue;
        }
      });
      return formattedEpisode;
    };

    return TVDB;

  })();

  module.exports = TVDB;

  module.exports.xmlParser = xmlParser;

}).call(this);
